const {expect} = require('chai');
const cliTest = require('./cli-test');
const path = require('path');
const writeFile = require('../lib/utils/file-write-logger');
const {baseFsWith, spec, singleScopeSpec, testGroupsSpec, translationWithSpecs, translationSpec} = require('./testkit');
const {without, and} = require('./test-utils');
const petriSpecsConvert = require('../lib/petri-specs-convert');
const sh = require('shelljs');

describe('petri-specs', () => {
  let test;
  beforeEach(() => test = cliTest.create(require.resolve('../bin/petri-specs.js')));
  afterEach(() => test.teardown());
  after(() => sh.rm('-rf', 'petri-specs') && sh.rm('-rf', 'dist'));

  it('should work for petri specs files', () => {
    const response = test
      .setup(baseFsWith({
        'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
        'petri-specs/MySpecName2.json': JSON.stringify(spec('MySpecName2'))
      }))
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 2 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
    expect(JSON.parse(test.content('petri-specs/MySpecName.json'))).to.eql(spec('MySpecName'));
    expect(JSON.parse(test.content('petri-specs/MySpecName2.json'))).to.eql(spec('MySpecName2'));
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
      spec('MySpecName'),
      spec('MySpecName2')
    ));
  });

  it('should filter invalid specs', () => {
    const response = test
      .setup(baseFsWith({
        'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
        'petri-specs/MySpecName2.json': JSON.stringify(spec('MySpecName2', without('scopes'))),
        'petri-specs/MySpecName3.json': JSON.stringify(spec('MySpecName3', without('owner'))),
        'petri-specs/MySpecName4.json': JSON.stringify(spec('MySpecName4', without('onlyForLoggedInUsers'))),
        'petri-specs/MySpecName5.json': JSON.stringify(spec('MySpecName5', without('controlGroup'))),
        'petri-specs/MySpecName6.json': JSON.stringify(spec('MySpecName6', without('variants')))
      }))
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stderr).to.contain('"MySpecName2" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName3" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName5" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName6" is not a valid spec');
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({}, spec('MySpecName')));
  });

  it('should validate scopes', () => {
    const response = test
      .setup(baseFsWith({
        'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
        'petri-specs/MySpecName2.json': JSON.stringify(spec('MySpecName2', and({scopes: ['a', 'a']}))),
        'petri-specs/MySpecName3.json': JSON.stringify(spec('MySpecName3', and({scopes: ['']}))),
        'petri-specs/MySpecName4.json': JSON.stringify(spec('MySpecName4', and({scopes: []}))),
        'package.json': ''
      }))
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stderr).to.contain('"MySpecName2" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName3" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({}, spec('MySpecName')));
  });

  it('should validate groups', () => {
    const response = test
      .setup(baseFsWith({
        'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
        'petri-specs/MySpecName2.json': JSON.stringify(spec('MySpecName2', and({controlGroup: '', variants: ['b']}))),
        'petri-specs/MySpecName3.json': JSON.stringify(spec('MySpecName3', and({controlGroup: 'a', variants: []}))),
        'petri-specs/MySpecName4.json': JSON.stringify(spec('MySpecName4', and({controlGroup: 'a', variants: ['']}))),
        'petri-specs/MySpecName5.json': JSON.stringify(spec('MySpecName5', and({controlGroup: 'a', variants: ['b', '']}))),
        'petri-specs/MySpecName6.json': JSON.stringify(spec('MySpecName6', and({controlGroup: 'a', variants: ['b', 'b']}))),
        'petri-specs/MySpecName7.json': JSON.stringify(spec('MySpecName7', and({controlGroup: 'a', variants: ['a']}))),
      }))
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stderr).to.contain('"MySpecName2" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName3" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName5" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName6" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName7" is not a valid spec');
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({}, spec('MySpecName')));
  });

  it('should require n !== 1 legal groups or more', () => {
    const response = test
      .setup(baseFsWith({
        'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName', and({controlGroup: 'a', variants: ['b', 'c']}))),
        'petri-specs/MySpecName2.json': JSON.stringify(spec('MySpecName2', and({controlGroup: 'a', variants: ['b']}))),
        'petri-specs/MySpecName3.json': JSON.stringify(spec('MySpecName3', and({controlGroup: '', variants: []}))),
        'petri-specs/MySpecName4.json': JSON.stringify(spec('MySpecName4', and({controlGroup: 'a', variants: []}))),
        'petri-specs/MySpecName5.json': JSON.stringify(spec('MySpecName5', and({controlGroup: 'a', variants: ['']}))),
        'petri-specs/MySpecName6.json': JSON.stringify(spec('MySpecName6', and({controlGroup: '', variants: ['b']}))),
      }))
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName5" is not a valid spec');
    expect(response.stderr).to.contain('"MySpecName6" is not a valid spec');
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 3 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
      spec('MySpecName', and({controlGroup: 'a', variants: ['b', 'c']})),
      spec('MySpecName2', and({controlGroup: 'a', variants: ['b']})),
      spec('MySpecName3', and({controlGroup: '', variants: []}))
    ));
  });

  it('should support multiple scopes', () => {
    const response = test
      .setup(baseFsWith({
        'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName', and({scopes: ['a', 'b', 'c']})))
      }))
      .execute('build');

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
      spec('MySpecName', and({scopes: ['a', 'b', 'c']}))
    ));
  });

  describe('backwards compatible', () => {
    describe('with scope', () => {
      it('should work', () => {
        const response = test
          .setup(baseFsWith({
            'petri-specs/MySpecName.json': JSON.stringify(singleScopeSpec('MySpecName')),
            'petri-specs/MySpecName2.json': JSON.stringify(singleScopeSpec('MySpecName2')),
          }))
          .execute('build');

        expect(response.code).to.equal(0);
        expect(response.stdout).to.contain('create dist/petri-experiments.json');
        expect(response.stdout).to.contain('found 2 valid specs');
        expect(response.stdout).to.contain('converted 2 specs');
        expect(JSON.parse(test.content('petri-specs/MySpecName.json'))).to.eql(spec('MySpecName'));
        expect(JSON.parse(test.content('petri-specs/MySpecName2.json'))).to.eql(spec('MySpecName2'));
        expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
          spec('MySpecName'),
          spec('MySpecName2')
        ));
      });

      it('should filter invalid specs', () => {
        const response = test
          .setup(baseFsWith({
            'petri-specs/MySpecName.json': JSON.stringify(singleScopeSpec('MySpecName')),
            'petri-specs/MySpecName2.json': JSON.stringify(singleScopeSpec('MySpecName2', without('scope'))),
            'petri-specs/MySpecName3.json': JSON.stringify(singleScopeSpec('MySpecName3', without('owner'))),
            'petri-specs/MySpecName4.json': JSON.stringify(singleScopeSpec('MySpecName4', without('onlyForLoggedInUsers'))),
            'petri-specs/MySpecName5.json': JSON.stringify(singleScopeSpec('MySpecName5', without('testGroups'))),
          }))
          .execute('build');

        expect(response.code).to.equal(0);
        expect(response.stderr).to.contain('"MySpecName2" is not a valid spec');
        expect(response.stderr).to.contain('"MySpecName3" is not a valid spec');
        expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
        expect(response.stderr).to.contain('"MySpecName5" is not a valid spec');
        expect(response.stdout).to.contain('create dist/petri-experiments.json');
        expect(response.stdout).to.contain('found 1 valid specs');
        expect(response.stdout).to.contain('converted 1 specs');
        expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
          spec('MySpecName')
        ));
      });
    });

    describe('with testGroups', () => {
      it('should work', () => {
        const response = test
          .setup(baseFsWith({
            'petri-specs/MySpecName.json': JSON.stringify(testGroupsSpec('MySpecName')),
            'petri-specs/MySpecName2.json': JSON.stringify(testGroupsSpec('MySpecName2')),
          }))
          .execute('build');

        expect(response.code).to.equal(0);
        expect(response.stdout).to.contain('create dist/petri-experiments.json');
        expect(response.stdout).to.contain('found 2 valid specs');
        expect(response.stdout).to.contain('converted 2 specs');
        expect(JSON.parse(test.content('petri-specs/MySpecName.json'))).to.eql(spec('MySpecName'));
        expect(JSON.parse(test.content('petri-specs/MySpecName2.json'))).to.eql(spec('MySpecName2'));
        expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
          spec('MySpecName'),
          spec('MySpecName2')
        ));
      });

      it('should filter invalid specs', () => {
        const response = test
          .setup(baseFsWith({
            'petri-specs/MySpecName.json': JSON.stringify(testGroupsSpec('MySpecName')),
            'petri-specs/MySpecName2.json': JSON.stringify(testGroupsSpec('MySpecName2', without('scopes'))),
            'petri-specs/MySpecName3.json': JSON.stringify(testGroupsSpec('MySpecName3', without('owner'))),
            'petri-specs/MySpecName4.json': JSON.stringify(testGroupsSpec('MySpecName4', without('onlyForLoggedInUsers'))),
            'petri-specs/MySpecName5.json': JSON.stringify(testGroupsSpec('MySpecName5', without('testGroups'))),
          }))
          .execute('build');

        expect(response.code).to.equal(0);
        expect(response.stderr).to.contain('"MySpecName2" is not a valid spec');
        expect(response.stderr).to.contain('"MySpecName3" is not a valid spec');
        expect(response.stderr).to.contain('"MySpecName4" is not a valid spec');
        expect(response.stderr).to.contain('"MySpecName5" is not a valid spec');
        expect(response.stdout).to.contain('create dist/petri-experiments.json');
        expect(response.stdout).to.contain('found 1 valid specs');
        expect(response.stdout).to.contain('converted 1 specs');
        expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
          spec('MySpecName')
        ));
      });

      it('should require any number of groups', () => {
        const response = test
          .setup(baseFsWith({
            'petri-specs/MySpecName.json': JSON.stringify(testGroupsSpec('MySpecName', and({testGroups: ['a', 'b', 'c']}))),
            'petri-specs/MySpecName2.json': JSON.stringify(testGroupsSpec('MySpecName2', and({testGroups: ['a', 'b']}))),
            'petri-specs/MySpecName3.json': JSON.stringify(testGroupsSpec('MySpecName3', and({testGroups: []}))),
          }))
          .execute('build');

        expect(response.code).to.equal(0);
        expect(response.stdout).to.contain('create dist/petri-experiments.json');
        expect(response.stdout).to.contain('found 3 valid specs');
        expect(response.stdout).to.contain('converted 3 specs');
        expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
          spec('MySpecName', and({controlGroup: 'a', variants: ['b', 'c']})),
          spec('MySpecName2', and({controlGroup: 'a', variants: ['b']})),
          spec('MySpecName3', and({controlGroup: '', variants: []}))
        ));
      });

      it('should support multiple scopes', () => {
        const response = test
          .setup(baseFsWith({
            'petri-specs/MySpecName.json': JSON.stringify(testGroupsSpec('MySpecName', and({scopes: ['a', 'b', 'c']}))),
          }))
          .execute('build');

        expect(response.code).to.equal(0);
        expect(response.stdout).to.contain('create dist/petri-experiments.json');
        expect(response.stdout).to.contain('found 1 valid specs');
        expect(response.stdout).to.contain('converted 1 specs');
        expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
          spec('MySpecName', and({scopes: ['a', 'b', 'c']}))
        ));
      });
    });
  });

  it('should do nothing if directory does not exist', () => {
    const response = test.setup(baseFsWith()).execute('build');
    expect(response.code).to.equal(0);
    expect(response.stdout).not.to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 0 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
  });

  it('has configurable directory parameter', () => {
    const response = test
      .setup(baseFsWith({
        'specs/MySpecName.json': JSON.stringify(spec('MySpecName'))
      }))
      .execute('build --directory specs');

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
      spec('MySpecName')
    ));
  });

  it('has configurable json parameter', () => {
    const response = test
      .setup(baseFsWith({
        'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName'))
      }))
      .execute('build --json abc/def.json');

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create abc/def.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
    expect(JSON.parse(test.content('abc/def.json'))).to.eql(Object.assign({},
      spec('MySpecName')
    ));
  });

  it('looks for the directory & json relatively to project top directory', () => {
    const response = test
      .setup(baseFsWith({
        'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
        'abc/placeholder.json': ''
      }))
      .execute('build', {}, {cwd: path.join(test.tmp, 'abc')});

    expect(response.code).to.equal(0);
    expect(response.stdout).to.contain('create ../dist/petri-experiments.json');
    expect(response.stdout).to.contain('found 1 valid specs');
    expect(response.stdout).to.contain('converted 0 specs');
    expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
      spec('MySpecName')
    ));
  });

  describe('translation specs', () => {
    it('should work', () => {
      const response = test
        .setup(baseFsWith({
          'src/assets/messages_en.json': JSON.stringify(translationWithSpecs('translation1', 'translation2'))
        }))
        .execute('build');

      expect(response.code).to.equal(0);
      expect(response.stdout).to.contain('create dist/petri-experiments.json');
      expect(response.stdout).to.contain('found 2 valid specs');
      expect(response.stdout).to.contain('converted 0 specs');
      expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
        translationSpec('specs.abTranslate.my-scope.translation1'),
        translationSpec('specs.abTranslate.my-scope.translation2')
      ));
    });

    it('should work for both translation specs and petri specs files', () => {
      const response = test
        .setup(baseFsWith({
          'src/assets/messages_en.json': JSON.stringify(translationWithSpecs('translation1')),
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName'))
        }))
        .execute('build');

      expect(response.code).to.equal(0);
      expect(response.stdout).to.contain('create dist/petri-experiments.json');
      expect(response.stdout).to.contain('found 2 valid specs');
      expect(response.stdout).to.contain('converted 0 specs');
      expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
        translationSpec('specs.abTranslate.my-scope.translation1'),
        spec('MySpecName')
      ));
    });

    it('should work without a pom file', () => {
      const response = test
        .setup({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          'src/assets/messages_en.json': JSON.stringify(translationWithSpecs('translation1', 'translation2')),
          'package.json': ''
        })
        .execute('build');

      expect(response.code).to.equal(0);
      expect(response.stdout).to.contain('create dist/petri-experiments.json');
      expect(response.stdout).to.contain('found 1 valid specs');
      expect(response.stdout).to.contain('converted 0 specs');
      expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({}, spec('MySpecName')));
    });
  });

  describe('petri-specs-convert', () => {
    it('should return the number of converted file when there are no files', () => {
      expect(petriSpecsConvert(testGroupsSpec('MySpecName'))).to.eql({convertedFilesCount: 0});
    });

    it('should return the number of converted file when there is one deprecated file', () => {
      writeFile('petri-specs/MySpecName.json', JSON.stringify(testGroupsSpec('MySpecName'), null, 2));
      expect(petriSpecsConvert({directory: 'petri-specs'})).to.eql({convertedFilesCount: 1});
    });

    it('should return the number of converted file when there is one file with the newer structure', () => {
      test
        .setup(baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          'package.json': ''
        }))
        .execute('build');

      expect(petriSpecsConvert(spec('MySpecName'))).to.eql({convertedFilesCount: 0});
    });

    it('should allow to set a scope', () => {
      const response = test
        .setup(baseFsWith({
          'src/assets/messages_en.json': JSON.stringify(translationWithSpecs('translation1'))
        }))
        .execute('build --scopes alt-scope,alt-scope2');

      expect(response.code).to.equal(0);
      expect(response.stdout).to.contain('create dist/petri-experiments.json');
      expect(response.stdout).to.contain('found 1 valid specs');
      expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
        translationSpec('specs.abTranslate.alt-scope.translation1', and({scopes: ['alt-scope', 'alt-scope2']}))
      ));
    });

    it('should allow to set onlyForLoggedInUsers', () => {
      const response = test
        .setup(baseFsWith({
          'src/assets/messages_en.json': JSON.stringify(translationWithSpecs('translation1'))
        }))
        .execute('build --only-for-logged-in-users false');

      expect(response.code).to.equal(0);
      expect(response.stdout).to.contain('create dist/petri-experiments.json');
      expect(response.stdout).to.contain('found 1 valid specs');
      expect(JSON.parse(test.content('dist/petri-experiments.json'))).to.eql(Object.assign({},
        translationSpec('specs.abTranslate.my-scope.translation1', and({onlyForLoggedInUsers: false}))
      ));
    });
  });
});
