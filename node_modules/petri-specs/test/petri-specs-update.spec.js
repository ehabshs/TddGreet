const {expect} = require('chai');
const proxyquire = require('proxyquire');
const sinon = require('sinon');
const eventually = require('wix-eventually').with({timeout: 2000, interval: 10});
const intercept = require('intercept-stdout');
const stripAnsi = require('strip-ansi');
const petriSpecsUpdate = require('../lib/petri-specs-update');
const {pom, baseFsWith, spec} = require('./testkit');
const writeFile = require('../lib/utils/file-write-logger');
const sh = require('shelljs');
const cliTest = require('./cli-test');

const apiServerHost = 'app-ci-jvm0a.42.wixprod.net';

function getUrl({groupId, artifactId, version}) {
  return `http://${apiServerHost}:27804/wix-petri-specs-feeder-webapp/api/v1/artifacts/${groupId}/${artifactId}/${version}-SNAPSHOT.`;
}

const groupId = 'com.wixpress';
const artifactId = 'petri-specs';
const version = '1.0.0';

describe('petri-specs-update', () => {
  describe('cli command', () => {
    let test;
    beforeEach(() => test = cliTest.create(require.resolve('../bin/petri-specs.js')));
    afterEach(() => test.teardown());

    it('should print the relevant data with respect to the pom.xml file', () => {
      const cli = test
        .setup(baseFsWith({
          'petri-specs/MySpecName.json': JSON.stringify(spec('MySpecName')),
          'pom.xml': pom({groupId, artifactId, version})
        }));

      cli.execute('build');
      const response = cli.execute('update');

      expect(response.code).to.equal(0);
      expect(response.stdout).to.contain('Updating experiments for:');
      expect(response.stdout).to.contain(`host:       ${apiServerHost}`);
      expect(response.stdout).to.contain(`groupId:    ${groupId}`);
      expect(response.stdout).to.contain(`artifactId: ${artifactId}`);
      expect(response.stdout).to.contain(`version:    ${version}-SNAPSHOT`);
      expect(response.stdout).to.contain('found 0 valid specs and 0 invalid specs');
    });
  });

  describe('function', () => {
    const validSpecs = [{specName: 'specs.infra.Valid'}, {specName: 'specs.infra.Valid2'}];
    const invalidSpecs = [{specName: 'specs.infra.Invalid'}, {specName: 'specs.infra.Invalid2'}];

    let stdout = '';
    let cleanup;

    before(() => cleanup = intercept(s => stdout += stripAnsi(s)));
    afterEach(() => stdout = '');
    after(() => cleanup());

    it('should fetch legal data from specs-feeder', () => {
      const fetchStub = sinon.stub()
        .returns(Promise.resolve({json: () => Promise.resolve({validSpecs, invalidSpecs})}));

      const proxyPetriSpecsUpdate = proxyquire('../lib/petri-specs-update', {'node-fetch': fetchStub});
      proxyPetriSpecsUpdate({pom: 'pom.xml'});

      return eventually(() => {
        expect(fetchStub.args[0][0]).to.equal(getUrl({groupId, artifactId, version}));
        expect(stdout).to.contain(`found ${validSpecs.length} valid specs and ${invalidSpecs.length} invalid specs`);
      });
    });

    it('should log error when missing the validSpecs array from specs-feeder response', () => {
      const errorDescription = 'missing validSpecs array';
      const fetchStub = sinon.stub()
        .returns(Promise.resolve({json: () => Promise.resolve({invalidSpecs, errorDescription})}));

      const proxyPetriSpecsUpdate = proxyquire('../lib/petri-specs-update', {'node-fetch': fetchStub});
      proxyPetriSpecsUpdate({pom: 'pom.xml'});

      return eventually(() => expect(stdout).to.contain(errorDescription));
    });

    it('should log error when missing the invalidSpecs array from specs-feeder response', () => {
      const errorDescription = 'missing invalidSpecs array';
      const fetchStub = sinon.stub()
        .returns(Promise.resolve({json: () => Promise.resolve({validSpecs, errorDescription})}));

      const proxyPetriSpecsUpdate = proxyquire('../lib/petri-specs-update', {'node-fetch': fetchStub});
      proxyPetriSpecsUpdate({pom: 'pom.xml'});

      return eventually(() => expect(stdout).to.contain(errorDescription));
    });

    it('should log error when getting an error from specs-feeder server', () => {
      const errorMessage = 'specs-feeder error';
      const proxyPetriSpecsUpdate = proxyquire('../lib/petri-specs-update', {'node-fetch': () => Promise.reject(errorMessage)});
      proxyPetriSpecsUpdate({pom: 'pom.xml'});

      return eventually(() => expect(stdout).to.contain(errorMessage));
    });

    it('should log errors when there is a bad pom.xml file path', () => {
      petriSpecsUpdate({pom: 'bad-file-path.xml'});

      return eventually(() => {
        expect(stdout).to.contain(`Error: ENOENT: no such file or directory, open 'bad-file-path.xml'`);
        expect(stdout).to.contain('please make sure you run this command from the root directory of the artifact');
      });
    });

    it('should log error when there is a bad formated pom.xml file', () => {
      writeFile('pom2.xml', JSON.stringify(pom(), null, 2));
      petriSpecsUpdate({pom: 'pom2.xml'});

      return eventually(() => {
        expect(stdout).to.contain('please make sure your pom.xml is valid');
        sh.rm('-rf', 'pom2.xml');
      });
    });

    it('should log error when there is an illegal version in pom.xml file', () => {
      writeFile('pom3.xml', pom({version: 'bad-version-format'}), null, 2);
      petriSpecsUpdate({pom: 'pom3.xml'});

      return eventually(() => {
        expect(stdout).to.contain(`invalid version:`);
        sh.rm('-rf', 'pom3.xml');
      });
    });
  });
});

